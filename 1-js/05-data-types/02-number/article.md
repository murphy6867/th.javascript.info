# Numbers

ในปัจจุบัน JavaScript มีประเภทของ Numbers อยู่ 2 ประเภท :

1. ตัวเลขปกติ (Regular numbers) ใน JavaScript จะถูกจัดเก็บในรูปแบบ 64-บิต [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision), หรือที่เรียกกันว่า "เลขทศนิยมที่มีความแม่นยำสองเท่า". นี่คือตัวเลขปกติที่เราใช้กันเป็นส่วนใหญ่ และเราจะพูดถึงตัวเลขปกติเหล่านี้ในบทนี้

2. ตัวเลข BigInt (BigInt numbers), ใช้ในการแสดงตัวเลขจำนวนเต็มที่มีจำนวนมาก. บางครั้งก็จำเป็นที่จะต้องใช้ เนื่องจากตัวเลขปกติ (Regular numbers) นั้นจัดเก็บตัวเลขได้ไม่เกิน <code>2<sup>53</sup></code> หรือค่าติดลบที่ <code>-2<sup>53</sup></code> ซึ่งมากกว่านั้นจะไม่มีความปลอดภัยในข้อมูลตัวเลข. เนื่องจาก Bigints ใช้ในเฉพาะกรณีพิเศษ, พวกเราจึงจัดทำหัวข้อพิเศษให้ <info:bigint>.

ในที่นี้เรามาพูดถึง ตัวเลขปกติ(Regular numbers) มาทำความเข้าใจเกี่ยวกับพวกมันกัน.
## มีหลายวิธีที่จะสร้างตัวเลขขึ้นมา

ลองนึกภาพพวกเราที่ต้องเขียนตัวเลข 1 พันล้าน วิธีที่ชัดเจนคือ:

```js
let billion = 1000000000;
```

เราสามารถใช้วิธีขีดเส้นใต้(underscore) `_` เป็นตัวขั้น:

```js
let billion = 1_000_000_000;
```

ในที่นี่เครื่องหมายขีดเส้นใต้(underscore) `_` มีบทบาทเป็น <sup>*1</sup>"syntactic sugar" ทำให้ตัวเลขอ่านง่ายขึ้น เอ็นจิ้น JavaScript จะละเว้น `_` ระหว่างตัวเลข ดังนั้นจึงเท่ากับหนึ่งพันล้านตามด้านบนทุกประการ
```
<sup>*1</sup>“Syntaxic Sugar” เป็นคำที่ใช้สำหรับการเปลี่ยนแปลงไวยากรณ์ในการเขียนโปรแกรมคอมพิวเตอร์ ซึ่งช่วยให้มนุษย์เขียนโค้ดได้ง่ายขึ้น
```

ในชีวิตจริง เราพยายามหลีกเลี่ยงการเขียนเลขศูนย์ต่อเนื่องกันยาวๆ เราขี้เกียจเกินไปสำหรับสิ่งนั้น เราจะพยายามเขียนประมาณว่า `"1 พันล้าน"` สำหรับหนึ่งพันล้าน หรือ `"7.3 พันล้าน"` สำหรับ 7 พัน 300 ล้าน เช่นเดียวกับตัวเลขขนาดใหญ่.

ใน JavaScript, เราสามารถย่อตัวเลขโดยต่อท้ายตัวอักษร `"e"` ต่อท้ายและระบุจำนวนศูนย์:

```js run
let billion = 1e9;  // 1 พันล้าน, ตามตัวอักษร: 1 และศูนย์ 9 ตัว

alert( 7.3e9 );  // 7.3 พันล้าน (เหมือนกับ 7300000000 หรือ 7_300_000_000)
```
กล่าวอีกนัยหนึ่ง, `e` คูณ `1` ด้วยเลขศูนย์ที่กำหนด

```js
1e3 === 1 * 1000; // e3 หมายถึง *1000
1.23e6 === 1.23 * 1000000; // e6 หมายถึง *1000000
```

ตอนนี้เรามาเขียนสิ่งที่เล็กมาก เช่น 1 ไมโครวินาที (หนึ่งในล้านของวินาที):

```js
let mсs = 0.000001;
```

เช่นเดียวกับก่อนหน้านี้, การใช้ `"e"` สามารถช่วยให้เราหลีกเลี่ยงการเขียนเลขศูนย์อย่างชัดเจน เราสามารถเขียนได้ดังนี้:

```js
let mcs = 1e-6; // เลขศูนย์หกตัวเพิ่มไปทางซ้ายมือของเลข 1
```

ถ้าเรานับเลขศูนย์ในจำนวน `0.000001`, จะมีจำนวน 6 ตัว. โดยปกติแล้วมันคือ `1e-6`.

กล่าวอีกนัยหนึ่ง, จำนวนลบที่ตามหลัง `"e"` หมายถึงการหารด้วย 1 ด้วยจำนวนศูนย์ที่กำหนด:

```js
// -3 คือการหาร 1 ด้วยศูนย์ 3 ตัว (1 / 1000)
1e-3 === 1 / 1000; // 0.001

// -6 อการหาร 1 ด้วยศูนย์ 6 ตัว (1 / 1000000)
1.23e-6 === 1.23 / 1000000; // 0.00000123
```

### เลขฐานสิบหก, เลขฐานสอง, และเลขฐานแปด


[เลขฐานสิบหก](https://en.wikipedia.org/wiki/Hexadecimal) มีการใช้กันอย่างแพร่หลายใน JavaScript เพื่อแสดงสี, เข้ารหัสอักขระ, และสำหรับสิ่งอื่นๆ อีกมากมาย ตามธรรมชาติแล้ว มีวิธีเขียนที่สั้นกว่านี้: `0x` แล้วตามด้วยตัวเลข

ตัวอย่างเช่น:

```js run
alert( 0xff ); // 255
alert( 0xFF ); // 255 (พิมพ์เล็กหรือพิมพ์ใหญ่ก็มีค่าเท่ากัน)
```

ระบบเลขฐานสองและเลขฐานแปดนั้นไม่ค่อยมีการใช้งานมากนัก แต่ยังสนับสนุนโดยใช้คำนำหน้า "0b" และ "0o":

```js run
let a = 0b11111111; // รูปแบบเลขฐานสองของ 255
let b = 0o377; // แบบเลขฐานแปดของ 255

alert( a == b ); // มีค่าเป็นจริง(true), ตัวเลขมีค่า 255 เท่ากันทั้งสองตัวแปล
```

มีเพียง 3 ระบบตัวเลขที่มีการรองรับดังกล่าว สำหรับระบบตัวเลขอื่นๆ เราควรใช้ฟังก์ชัน `parseInt` (ซึ่งเราจะเห็นต่อไปในบทนี้)

## toString(base) // toString(เลขฐาน)

วิธีการ `num.toString(base)` ส่งคืนสตริงที่แทน `num` ในระบบตัวเลขด้วย `base` ที่กำหนด
ตัวอย่างเช่น:

```js run
let num = 255;

alert( num.toString(16) );  // ff (เป็นเลขฐาน 16)
alert( num.toString(2) );   // 11111111 (เป็นเลขฐาน 2)
```

เลขฐาน `base` สามารถเปลี่ยนแปลงเลขฐานได้ตั้งแต่ `2` ถึง `36`. โดยค่าเริ่มต้นคือ `10`.

กรณีการใช้งานทั่วไปสำหรับสิ่งนี้คือ:

- **base=16** ใช้สำหรับสีฐานสิบหก, การเข้ารหัสอักขระ, ฯลฯ ซึ่งตัวเลขสามารถเป็นไปได้ตั้งแต่ `0..9` หรือ `A..F`
- **base=2** ส่วนใหญ่ใช้สำหรับการดีบักการดำเนินการระดับบิต(bits) ตัวเลขอาจเป็น `0` หรือ `1`
- **ฐาน=36** คือค่าสูงสุดของเลขฐาน ตัวเลขสามารถเป็น `0..9` หรือ `A..Z` ตัวอักษรละตินทั้งหมดใช้แทนตัวเลขได้ มีประโยชน์สำหรับ `36` คือเมื่อเราจำเป็นต้องเปลี่ยนตัวระบุที่เป็นตัวเลขแบบยาวให้เป็นตัวระบุที่สั้นลง เช่น เพื่อสร้าง URL แบบสั้น สามารถแสดงในระบบตัวเลขที่มีฐาน `36`:

    ```js run
    alert( 123456..toString(36) ); // 2n9c
    ```

```คำเตือน = "เรียกเมธอดด้วยจุดสองจุด .. "
โปรดทราบว่าจุดสองจุดใน `123456..toString(36)` ไม่ใช่การพิมพ์ผิด หากเราต้องการเรียกใช้เมธอดโดยตรงบนตัวเลข เช่น `toString` ในตัวอย่างข้างต้น เราจะต้องวางจุด `..` สองจุดตามหลัง

หากเราใส่จุดเดียว: `123456.toString(36)` จะเกิดข้อผิดพลาด เนื่องจากไวยากรณ์ของ JavaScript แสดงถึงส่วนทศนิยมหลังจุดแรก และถ้าเราวางอีกหนึ่งจุด JavaScript จะรู้ว่าส่วนทศนิยมนั้นว่างเปล่าและตอนนี้ไปที่เมธอด

นอกจากนี้ยังสามารถเขียน `(123456).toString(36)` แทนได้

```

## การปัดเศษ

หนึ่งในการดำเนินการที่ใช้มากที่สุดเมื่อทำงานกับตัวเลขคือการปัดเศษ

มีฟังก์ชันในตัวหลายฟังก์ชันสำหรับการปัดเศษ:

`Math.floor`
: ปัดเศษลง: `3.1` เป็น `3`, และ `-1.1` เป็น `-2`.

`Math.ceil`
: ปัดเศษขึ้น: `3.1` เป็น `4`, และ `-1.1` เป็น `-1`.

`Math.round`
: ปัดเศษไปที่ค่าจำนวนเต็มที่ใกล้เคียงที่สุด: `3.1` เป็น `3`, `3.6` เป็น `4`, กรณีค่ากลาง: `3.5` จะถูกปัดขึ้น `4` เช่่นเดียวกัน.

`Math.trunc` (ไม่รองรับใน Internet Explorer(IE))
: ลบทุกอย่างที่อยู่หลังจุดทศนิยมโดยไม่มีการปัดเศษ: `3.1` จะกลายเป็น `3`, `-1.1` จะกลายเป็น `-1.

นี่คือตารางเพื่อสรุปความแตกต่างระหว่างวิธีต่างๆ:

|   | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
|---|---------|--------|---------|---------|
|`3.1`|  `3`    |   `4`  |    `3`  |   `3`   |
|`3.6`|  `3`    |   `4`  |    `4`  |   `3`   |
|`-1.1`|  `-2`    |   `-1`  |    `-1`  |   `-1`   |
|`-1.6`|  `-2`    |   `-1`  |    `-2`  |   `-1`   |


ฟังก์ชันเหล่านี้ครอบคลุมวิธีที่เป็นไปได้ทั้งหมดในการจัดการกับส่วนทศนิยมของตัวเลข แต่ถ้าเราต้องการปัดเศษตัวเลขให้เป็น "n-th" หลักหลังจุดทศนิยมล่ะ?

ตัวอย่างเช่น, เรามีตัวเลข `1.2345` และต้องการปัดเศษให้เป็นเศษ 2 หลัก จะได้ "1.23".
มีสองวิธีที่ทำได้:

1. วิธีการนำมาคูณและนำมาหาร.

    ตัวอย่างเช่น ในการปัดเศษตัวเลขให้เป็นเลข 2 หลักหลังทศนิยม เราสามารถคูณจำนวนด้วย `100` (หรือยกกำลัง 10), เรียกใช้ฟังก์ชันการปัดเศษแล้วหารด้วยจำนวณ `100`

```js run
    let num = 1.23456;

    alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. วิธี [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed) ปัดเศษตัวเลขจำนวน n หลัก หลังจุดทศนิยม และส่งกลับสตริงเพื่อแสดงผลลัพธ์.

    ```js run
    let num = 12.34;
    alert( num.toFixed(1) ); // "12.3"
    ```

การปัดเศษขึ้นหรือลงให้เป็นค่าที่ใกล้ที่สุด คล้ายกับ `Math.round`:

    ```js run
    let num = 12.36;
    alert( num.toFixed(1) ); // "12.4"
    ```

    โปรดทราบว่าผลลัพธ์ของ `toFixed` จะเป็นสตริง. ถ้าทศนิยมที่มีสั้นกว่าค่าที่กำหนดลงฟังก์ชั่น เลขศูนย์จะต่อท้ายผลลัพธ์:

    ```js run
    let num = 12.34;
    alert( num.toFixed(5) ); // "12.34000", added zeroes to make exactly 5 digits
    ```
    เราสามารถแปลงผลลัพธ์เป็นตัวเลขได้โดยใช้การเรียก unary plus(+) หรือ Number() เช่น การเขียน +num.toFixed(5).

## การคำนวณที่ไม่แม่นยำ

โครงสร้างภายในของตัวเลขนั้นจะแสดงในรูปแบบ 64-บิต [IEEE-754](https://en.wikipedia.org/wiki/IEEE_754-2008_revision), ดังนั้น 64-บิต จะแบ่งการจัดเก็บตัวเลขออกเป็น: 52-บิต จะถูกใช้ในการจัดเก็บตัวเลข, 11-บิต ใช้ในการจัดเก็บตำแหน่งของจุดทศนิยม (จะแสดงเป็นเลขศูนย์สำหรับจำนวนเต็ม), และ 1-บิต สำหรับจัดเก็บเครื่องหมาย.

หากตัวเลขมีจำนวนมากจริงๆ อาจล้นพื้นที่เก็บข้อมูล 64 บิตและกลายเป็นค่าตัวเลขพิเศษแบบไม่มีที่สิ้นสุด:

```js run
alert( 1e500 ); // อินฟินิตี้(ไม่สิ้นสุด)
```

สิ่งที่อาจไม่ค่อยชัดเจนนัก แต่เกิดขึ้นค่อนข้างบ่อยคือการสูญเสียความแม่นยำ

พิจารณาการทดสอบความเท่าเทียมกัน (เป็นเท็จ!) นี้:

```js run
alert( 0.1 + 0.2 == 0.3 ); // *!*เป็นเท็จ*/!*
```

That's right, if we check whether the sum of `0.1` and `0.2` is `0.3`, we get `false`.

Strange! What is it then if not `0.3`?
ถูกต้องแล้ว, ถ้าเราตรวจสอบว่าผลรวมของ 0.1 และ 0.2 คือ 0.3 เราจะได้เป็นเท็จ

แปลกมาก!, แล้วถ้าไม่ใช่ 0.3 แล้วมันเท่าไหร่ล่ะ?

```js run
alert( 0.1 + 0.2 ); // 0.30000000000000004
```

อุ๊ย! มีผลที่ตามมามากกว่าการเปรียบเทียบที่ผลเป็นเท็จ. ลองนึกภาพว่าคุณกำลังสร้างเว็บไซต์ช้อปปิ้งออนไลน์ และผู้ใช้งานใส่สินค้าราคา `$0.10` และ `$0.20` ลงในรถเข็นของพวกเขา ยอดรวมของคำสั่งซื้อจะเท่ากับ `$0.30000000000000004` นั่นจะทำให้ทุกคนประหลาดใจ

แต่ทำไมสิ่งนี้ถึงเกิดขึ้น?

ตัวเลขถูกเก็บไว้ในหน่วยความจำในรูปแบบเลขฐานสอง, ลำดับของบิต - หนึ่งและศูนย์ แต่เศษส่วนเช่น `0.1`, `0.2` ที่ดูเหมือนง่ายในระบบเลขฐานสิบนั้น จริง ๆ แล้วเป็นเศษส่วนที่ไม่รู้จบในรูปแบบเลขฐานสอง.

กล่าวอีกนัยหนึ่งว่า `0.1` คืออะไร? มันคือหนึ่งหารด้วยสิบ `1/10` หรือหนึ่งในสิบ. ในระบบเลขฐานสิบ ตัวเลขดังกล่าวสามารถแสดงได้ง่าย. เปรียบเทียบกับหนึ่งในสาม: `1/3` มันกลายเป็นเศษส่วนไม่รู้จบ `0.33333(3)`.

ดังนั้น การหารด้วยเลขยกกำลัง `10` จึงรับประกันได้ว่าจะใช้ได้ดีในระบบทศนิยม แต่การหารด้วย `3` นั้นไม่ใช่ ด้วยเหตุผลเดียวกัน ในระบบเลขฐานสอง การหารด้วยเลขยกกำลังของ `2` รับประกันว่าจะได้ผล แต่ `1/10` กลายเป็นเศษส่วนเลขฐานสองที่ไม่รู้จบ.

ไม่มีวิธีจัดเก็บ *0.1 ที่แท้จริง* หรือ *0.2 ที่แท้จริง* ด้วยการใช้ระบบเลขฐานสอง เช่นเดียวกับที่ไม่มีวิธีจัดเก็บหนึ่งในสามเป็นเศษส่วนทศนิยม.

รูปแบบตัวเลข IEEE-754 ได้แก้ปัญหานี้โดยการปัดเศษให้เป็นตัวเลขที่ใกล้เคียงที่สุด โดยปกติกฎการปัดเศษเหล่านี้ไม่อนุญาตให้เราเห็นว่ามี "การสูญเสียความแม่นยำเพียงเล็กน้อย" แต่มันมีอยู่จริง.

เราสามารถเห็นสิ่งนี้ในการดำเนินการ:

```js run
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```

และเมื่อเรารวมตัวเลขสองตัว ค่า"การสูญเสียความแม่นยำ" ก็จะเพิ่มขึ้น

นั่นเป็นเหตุผลว่าทำไม `0.1 + 0.2` จึงไม่ใช่ `0.3` เป๊ะๆ

```smart header="ไม่ใช่แค่จาวาสคริปต์เท่านั้น"

ปัญหาเดียวกันนี้มีอยู่ในภาษาโปรแกรมอื่นๆ จำนวนมาก

PHP, Java, C, Perl, Ruby ให้ผลลัพธ์ที่เหมือนกันทุกประการ เนื่องจากใช้รูปแบบตัวเลขเดียวกัน
```

เราสามารถแก้ไขปัญหาได้หรือไม่? แน่นอนว่าวิธีที่น่าเชื่อถือที่สุดคือการปัดเศษผลลัพธ์ด้วยความช่วยเหลือของวิธีการ [toFixed(n)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed):

```js run
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```

โปรดทราบว่า toFixed จะส่งคืนค่าสตริงเสมอ. ตรวจสอบให้แน่ใจว่ามีเลข 2 หลักหลังจุดทศนิยม. มันสะดวกจริงๆ ถ้าเรามี e-shopping และต้องการแสดง $0.30 สำหรับกรณีอื่นๆ เราสามารถใช้ unary plus เพื่อบังคับให้มันเป็นตัวเลขได้:

```js run
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

เรายังสามารถคูณตัวเลขชั่วคราวด้วย 100 (หรือจำนวนที่มากกว่า) เพื่อเปลี่ยนให้เป็นจำนวนเต็ม, คำนวณเลขแล้วหารกลับ. จากนั้น ขณะที่เรากำลังคำนวณเลขจำนวนเต็ม ข้อผิดพลาดจะลดลง แต่ยังคงมีข้อผิดพลาดหลังจากการหาร:

```js run
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
```

ดังนั้น วิธีคูณ/หาร ช่วยลดข้อผิดพลาด แต่ก็ไม่ได้ลบออกทั้งหมด.

บางครั้งเราอาจพยายามหลีกเลี่ยงเศษส่วน. เช่นเดียวกับถ้าเราต่อรองราคากับร้านค้า เราสามารถเก็บราคาเป็นสลึงแทนบาท. แต่ถ้าเราใช้ส่วนลด 30% ล่ะ? ในทางปฏิบัติ แทบจะเป็นไปไม่ได้เลยที่จะหลีกเลี่ยงเศษส่วน เพียงปัดเศษเพื่อตัด "หาง" เมื่อจำเป็น

````smart header="สิ่งที่น่าตลก"
ลองรันโปรแกรมนี้ดู:

```js run
// สวัสดี! ฉันเป็นคนที่เพิ่มจำนวนขึ้นด้วยตัวเอง!
alert( 9999999999999999 ); // ผลลัพธ์ 10000000000000000
```
สิ่งนี้ประสบปัญหาเดียวกัน: คือการสูญเสียความแม่นยำ. มี 64-บิต สำหรับตัวเลข, 52-บิตสามารถใช้เก็บตัวเลขได้ แต่นั่นยังไม่เพียงพอ ตัวเลขที่มีนัยสำคัญน้อยที่สุดจึงหายไป.

JavaScript ไม่ก่อให้เกิดข้อผิดพลาดในเหตุการณ์ดังกล่าว วิธีที่ดีที่สุดคือใส่ตัวเลขให้พอดีกับรูปแบบที่ต้องการ แต่น่าเสียดายที่รูปแบบนี้ไม่ใหญ่พอ
````

```smart header="เลขศูนย์ สองตัว"

In most cases the distinction is unnoticeable, because operators are suited to treat them as the same.
ผลลัพธ์ที่น่าตลกอีกอย่างหนึ่งของการแทนตัวเลขภายในคือการมีอยู่ของศูนย์สองตัว: 0 และ -0

นั่นเป็นเพราะเครื่องหมายถูกแทนด้วยบิต(bit)เดียว ดังนั้นจึงสามารถตั้งค่าหรือไม่ตั้งค่าสำหรับตัวเลขใดๆ รวมทั้งศูนย์

ในกรณีส่วนใหญ่ ความแตกต่างนั้นไม่สามารถสังเกตเห็นได้ เนื่องจากตัวดำเนินการนั้นเหมาะสมที่จะปฏิบัติต่อสิ่งเหล่านั้นเหมือนกัน
```

## ทดสอบ: isFinite และ isNaN

จำค่าตัวเลขพิเศษสองค่านี้ได้ไหม?

- `Infinity` (และ `-Infinity`) เป็นค่าตัวเลขที่มากกว่า (น้อยกว่า) ค่าใดๆ.
- `NaN` แสดงถึงข้อผิดพลาด

พวกเขาอยู่ในประเภทของ `ตัวเลข` แต่ไม่ใช่ตัวเลขที่ "ปกติ" ดังนั้นจึงมีฟังก์ชันพิเศษในการตรวจสอบ:

- `isNaN(ค่า, ตัวแปร)` แปลงฟังก์ชั่นอาร์กิวเมนต์เป็นตัวเลขแล้วทดสอบว่าเป็น `NaN` หรือไม่:

    ```js run
    alert( isNaN(NaN) ); // เป็นจริง (true)
    alert( isNaN("str") ); // เป็นจริง (true)
    ```

    แต่เราต้องการฟังก์ชั่นนี้จริงหรอ? เราใช้การเปรียบเทียบ `=== NaN` ไม่ได้หรอ? แต่น่าเสียดายที่คำตอบคือไม่ได้. ค่า `NaN` นั้นเป็นเอกลักษณ์เนื่องจากไม่เท่ากับสิ่งใดเลย รวมถึงตัวมันเองด้วย:

    ```js run
    alert( NaN === NaN ); // เป็นเท็จ (false)
    ```

- `isFinite(value)` แปลงฟังก์ชั่นอาร์กิวเมนต์เป็นตัวเลขและส่งกลับ`ค่าจริง(true)` หากเป็นตัวเลขปกติ ไม่ใช่ -`%NaN/Infinity/-Infinity`:

    ```js run
    alert( isFinite("15") ); // เป็นจริง (true)
    alert( isFinite("str") ); // เป็นเท็จ (false), เพราะมีค่าพิเศษคือ: NaN
    alert( isFinite(Infinity) ); // เป็นเท็จ (false), เพราะมีค่าพิเศษคือ: Infinity
    ```

บางครั้ง `isFinite` ใช้ในการตรวจสอบว่าค่าสตริงเป็นตัวเลขปกติหรือไม่:

```js run
let num = +prompt("Enter a number", '');

// จะเป็นจริงเว้นแต่คุณจะใส่ค่า Infinity, -Infinity หรือไม่ใช่ตัวเลข
alert( isFinite(num) );
```

โปรดทราบว่าสตริงว่างหรือเว้นวรรคถือเป็น `0` ในฟังก์ชันตัวเลขทั้งหมดรวมถึง `isFinite`.

```smart header="เปรียบเทียบด้วย `Object.is`"

มีวิธีแบบพิเศษ [`Object.is`](mdn:js/Object/is) ที่เปรียบเทียบค่าต่างๆ เหมือนกับ `===` แต่เชื่อถือได้มากกว่าสำหรับกรณีสองแบบดังนี้:
1. มันใช้งานได้กับ `NaN`: `Object.is(NaN, NaN) === เป็นจริง(true)`, นั่นเป็นสิ่งที่ดี.
2. ค่าของ `0` และ `-0` นั้นแตกต่างกัน: `Object.is(0, -0) === เป็นเท็จ(false)`, ซึ่งทางเทคนิคแล้วเป็นสิ่งที่ถูกต้อง, เนื่องจากตัวเลขภายในมีบิต(bit)เครื่องหมายที่อาจแตกต่างกันแม้ว่าบิตอื่นๆ ทั้งหมดจะเป็นศูนย์ก็ตาม.

ในกรณีอื่นๆนั้น, `Object.is(a, b)` ก็จะเหมือนกับ `a === b`.

วิธีการเปรียบเทียบนี้มักใช้ในข้อมูลจำเพาะของ JavaScript เมื่ออัลกอริทึมภายในจำเป็นต้องเปรียบเทียบค่าสองค่าเพื่อให้เหมือนกันทุกประการ อัลกอริทึมจะใช้ `Object.is` (เรียกกันอีกอย่างว่า [SameValue](https://tc39.github.io/ecma262/#sec-samevalue)).
```


## parseInt และ parseFloat

วิธีกการแปลงตัวเลขโดยใช้เครื่องหมายบวก `+` หรือ `Number()` นั้นเข้มงวด. หากค่าไม่ใช่ตัวเลขทั้งหมด ก็จะล้มเหลว:

```js run
alert( +"100px" ); // NaN (Not-a-Number)
```

ข้อยกเว้นเพียงอย่างเดียวคือการเว้นวรรคที่จุดเริ่มต้นหรือจุดสิ้นสุดของสตริง เนื่องจากจะถูกละเว้น

แต่ในชีวิตจริงเรามักจะมีค่าเป็นหน่วย เช่น `"100px"` หรือ `"12pt`" ใน CSS. นอกจากนี้ ในหลายประเทศ สัญลักษณ์สกุลเงินอยู่หลังจำนวนเงิน เราจึงมี `"19€"` และต้องการแยกค่าตัวเลขออกจากค่านั้น.

นั่นคือสิ่งที่ `parseInt` และ `parseFloat` ทำ.

พวกเขา "อ่าน" ตัวเลขจากสตริงจนกว่าจะอ่านไม่ได้. ในกรณีที่เกิดข้อผิดพลาด ระบบจะส่งกลับตัวเลขที่รวบรวมไว้ได้และ ฟังก์ชัน parseInt ส่งคืนจำนวนเต็ม ในขณะที่ parseFloat จะส่งกลับตัวเลขทศนิยม:

```js run
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, ส่งคืนเฉพาะจำนวนเต็มเท่านั้น
alert( parseFloat('12.3.4') ); // 12.3, เมื่อเจอจุดทศนิยมที่สองจะไม่ถูกส่งคืนเพราะไม่ใช่ตัวเลข
```

มีบางสถานการณ์ที่ `parseInt/parseFloat` จะคืนค่า `NaN`. มันจะเกิดขึ้นต่อเมื่อไม่สามารถอ่านตัวเลขได้:

```js run
alert( parseInt('a123') ); // NaN, สัญญาลักษณ์แรกไม่ใช่ตัวเลข จึงหยุดการทำงานของฟังก์ชั่น
```

````smart header="อาร์กิวเมนต์ที่สองของฟังก์ชั่น `parseInt(str, radix)`"
ฟังก์ชัน `parseInt()` จะมีพารามิเตอร์ที่สองหรือไม่มีก็ได้. มันถูกใช้ระบุฐานของระบบตัวเลข ดังนั้น parseInt ยังสามารถแยกวิเคราะห์สตริงของเลขฐานสิบหก เลขฐานสอง และอื่นๆ:

```js run
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, สามารถใช้งานได้แม้ไม่มี 0x 

alert( parseInt('2n9c', 36) ); // 123456
```
````

## ฟังก์ชันทางคณิตศาสตร์อื่นๆ

JavaScript มีฟังก์ชั่นทางคณิตศาสตร์ [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math) จำนวนจำนวนมากและมีไลบรารีแยกย่อยของฟังก์ชันทางคณิตศาสตร์และค่าคงที่ให้ใช้งานเยอะ.
ตัวอย่างบางส่วน:

`Math.random()`
: คืนค่าตัวเลขสุ่มจาก 0 ถึง 1 (ไม่รวม 1)

    ```js run
    alert( Math.random() ); // 0.1234567894322
    alert( Math.random() ); // 0.5435252343232
    alert( Math.random() ); // ... (ตัวเลขสุ่มใดๆ)
    ```

`Math.max(a, b, c...)` และ `Math.min(a, b, c...)`
: ส่งกลับ ค่าที่มากที่สุด/น้อยที่สุด จากจำนวนอาร์กิวเมนต์.

    ```js run
    alert( Math.max(3, 5, -10, 0, 1) ); // 5
    alert( Math.min(1, 2) ); // 1
    ```

`Math.pow(n, power)`
: ส่งกลับ `n` ยกกำลังที่กำหนด

    ```js run
    alert( Math.pow(2, 10) ); // 2 in power 10 = 1024
    ```

มีฟังก์ชันและค่าคงที่อื่นๆ อีกมากมายในวัตถุทาง`คณิตศาสตร์` รวมถึงตรีโกณมิติ, ซึ่งคุณสามารถค้นหาได้ใน[เอกสารสำหรับวัตถุทางคณิตศาสตร์](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math).

## สรุป

ในการเขียนตัวเลขที่มีศูนย์หลายตัว:

- ต่อท้าย "e" ด้วยจำนวนของเลขศูนย์ที่ต้องการ. เช่น: `123e6` เหมือนกับ `123` ที่มีเลขศูนย์ 6 ตัว `123000000`.
- จำนวนที่ติดลบหลัง `"e"` คือจำนวนเลขศูนย์ที่จะเพิ่มขึ้นทางด้านซ้าย. เช่น `123e-6` คือ `0.000123` (`123` ในล้าน).

สำหรับระบบตัวเลขต่างๆ:

- สามารถเขียนตัวเลขได้โดยตรงในระบบฐานสิบหก (`0x`) ฐานแปด (`0o`) และฐานสอง (`0b`).
- `parseInt(str, base)` แยกวิเคราะห์สตริง `str` เป็นจำนวนเต็มในระบบที่มี`เลขฐาน`ที่กำหนด, `2 ≤ ฐาน ≤ 36`.
- `num.toString(base)` ปลงตัวเลขเป็นสตริงในระบบด้วย`เลขฐาน`ที่กำหนด.

สำหรับการแปลงค่า เช่น `12pt` และ `100px` เป็นตัวเลข:

- ใช้ `parseInt/parseFloat` สำหรับการแปลง "ซอฟต์" ซึ่งอ่านตัวเลขจากสตริงแล้วส่งคืนค่าที่อ่านได้ก่อนเกิดข้อผิดพลาด.

สำหรับเศษส่วน:

- ปัดเศษโดยใช้ `Math.floor`, `Math.ceil`, `Math.trunc`, `Math.round` หรือ `num.toFixed(ความแม่นยำ)`.
- อย่าลืม! จำไว้ว่ามีการสูญเสียความแม่นยำเมื่อทำงานกับเศษส่วน.

ฟังก์ชันทางคณิตศาสตร์เพิ่มเติม:

- ดูได้ที่ [Math](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Math)
ดูออบเจ็กทางคณิตศาสตร์เมื่อคุณต้องการ ไลท์บารีนั้นมีขนาดเล็ก แต่สามารถรองรับความต้องการขั้นพื้นฐานได้
